Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії





Лабораторна робота № 2
з дисципліни «Аналіз та рефакторинг коду»








Виконав:									Перевірив:
ст. гр. ПЗПІ-22-8								ст. викладач. 
Кушнірук Денис 								Сокорчук І.П









Харків 2024

1 Розробка бази даних для серверної частини програмної системи та прикладного програмного інтерфейсу

1.1 Мета роботи: 
Розробка серверної частини програмної системи для автоматичного управління освітленням у приміщеннях

1.2 Хід роботи
Розробити будову програмної системи для автоматичного управління освітленням у приміщеннях.

1.2.1 Створення UML діаграми прецедентів

Для системи автоматизованого управління освітленням використовуються кілька основних акторів та сценаріїв. Користувачі реєструються та авторизуються через електронну пошту або соціальні мережі для доступу до своїх акаунтів і налаштувань. Вони можуть керувати освітленням, створювати розклади для автоматичного ввімкнення та вимкнення освітлення, а також налаштовувати персоналізовані сценарії освітлення, такі як "робочий" або "відпочинок". Адміністратори мають розширені права для управління користувачами, налаштування глобальних параметрів системи та моніторингу активності. IoT пристрої виконують команди від системи, змінюючи стан освітлення відповідно до заданих сценаріїв або розкладів. Система надсилає команди IoT пристроям, щоб вони виконували ці функції, забезпечуючи ефективне автоматичне управління освітленням у приміщеннях.
 
Рис. 1 – Use case diagram серверної частини додатку

1.2.2 Розробка ER діаграми
Для ефективно функціонування системи, швидкого доступу до інформації та гарантії цілісності даних була розроблена дана структура бази даних. Ця структура бази даних дозволяє забезпечити масштабованість, безпеку та ефективність системи, а також дає змогу зберігати необхідні дані для управління освітленням у приміщеннях та моніторингу роботи системи.

 
Рис. 2 – ER diagram бази даних
1.2.3 Розробка бази даних програмної системи
Це рішення для бази даних розроблено з урахуванням вимог для автоматизованого контролю освітлення у приміщеннях. Загалом, таке рішення дозволяє гнучко управляти освітленням у приміщеннях, створювати різноманітні сценарії та розклади, а також відслідковувати дії користувачів.

 
Table Users {
id INT [pk, increment] // Унікальний ідентифікатор користувача
email VARCHAR(255) [unique, not null] // Email користувача
password VARCHAR(255) // Хешований пароль (для користувачів, що не використовують соціальний вхід)
role ENUM('user', 'admin') [default: 'user'] // Роль користувача
firstName VARCHAR(255) [not null] // Ім'я користувача
lastName VARCHAR(255) [not null] // Прізвище користувача
profileImage VARCHAR(255) // URL або шлях до зображення профілю користувача
}
Table Rooms {
id             INT [pk, increment] // Унікальний ідентифікатор кімнати
user_id        INT [not null, ref: > Users.id] // Користувач, якому належить кімната
name           VARCHAR(255) [not null] // Назва кімнати (наприклад, "Кухня")
}
Table Logs {
id             INT [pk, increment] // Унікальний ідентифікатор журналу
user_id        INT [not null, ref: > Users.id] // Користувач, що виконав дію
room_id        INT [ref: > Rooms.id] // Кімната, до якої відноситься запис
action         VARCHAR(255) [not null] // Опис дії (наприклад, "Увімкнено освітлення")
timestamp      DATETIME [not null] // Час виконання дії
}
Table Lights {
  id             INT [pk, increment] // Унікальний ідентифікатор освітлення
  room_id        INT [not null, ref: > Rooms.id] // Кімната, до якої прив'язане освітлення
  status         BOOLEAN [default: false] // Статус: false - вимкнено, true - увімкнено
  brightness     INT [default: 100] // Рівень яскравості (від 0 до 100)
  lastActivated  DATETIME // Останній час активації
  scheduleStart  DATETIME // Час початку автоматичного ввімкнення
  scheduleEnd    DATETIME // Час завершення автоматичного ввімкнення
  motionDetected BOOLEAN [default: false] // Чи виявлений рух для автоматичного ввімкнення
}
 
1.2.4 Створення діаграми структури БД
1. Користувачі (Users): У системі існують різні ролі користувачів, такі як звичайні користувачі та адміністратори. Кожен користувач має унікальний ідентифікатор (UID), пов’язаний з його обліковим записом, та основні дані, такі як ім’я, електронна пошта, роль, що дозволяють налаштовувати інтерфейс під конкретного користувача.
2. Кімнати (Rooms): Кімнати є основною складовою системи управління освітленням. Кожна кімната належить до певного користувача та має унікальний ідентифікатор, а також назву (наприклад, "Кухня" чи "Вітальня"). Ця структура дозволяє користувачам налаштовувати окремі параметри освітлення, розклади або сценарії для кожної кімнати окремо.
3. Логування (Logs): Всі дії, що виконуються в системі (включення/вимикання освітлення, зміни в налаштуваннях, створення сценаріїв), зберігаються в таблиці логів. Це дозволяє адміністраторам відслідковувати активність користувачів, історію змін, а також можливі збої або неполадки в роботі пристроїв.
4. Освітлення (Lights): Таблиця освітлення є ключовим елементом системи управління освітленням. Вона містить дані, пов'язані з окремими джерелами світла в кімнатах, їхніми статусами, рівнями яскравості та іншими параметрами, що дозволяють налаштовувати автоматизацію та управління освітленням.
 
Рис. 3 – Структура бази даних
Ця структура бази даних дозволяє забезпечити масштабованість, безпеку та ефективність системи, а також дає змогу зберігати необхідні дані для управління освітленням у приміщеннях та моніторингу роботи системи.

1.2.5 Функції роботи з БД (ORM)
Для роботи з базою даних MongoDB у було обрано Mongoose, що є популярною бібліотекою для Node.js, яка забезпечує зручний інтерфейс для взаємодії з MongoDB. Mongoose дозволяє створювати моделі, що представляють структуру даних у базі, та надає можливості для роботи з документами, такими як додавання, оновлення, видалення та пошук.

 
const mongoose = require("mongoose");
const userSchema = new mongoose.Schema(
  {
    email: { type: String, required: true, unique: true },
    password: { type: String, required: true },
    role: { type: String, enum: ["user", "admin"], default: "user" },
    firstName: { type: String, required: true },
    lastName: { type: String, required: true },
    profileImage: { type: String },
  },
  { versionKey: false }
);
const User = mongoose.model("User", userSchema);
module.exports = User;
const mongoose = require("mongoose");
const roomSchema = new mongoose.Schema(
  {
    user_id: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    name: { type: String, required: true },
  },
  { versionKey: false }
);
const Room = mongoose.model("Room", roomSchema);
module.exports = Room;
const mongoose = require("mongoose");
const logSchema = new mongoose.Schema(
  {
    user_id: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    room_id: { type: mongoose.Schema.Types.ObjectId, ref: "Room" },
    action: { type: String, required: true },
    timestamp: { type: Date, required: true },
  },
  { versionKey: false }
);
const Log = mongoose.model("Log", logSchema);
module.exports = Log;
const mongoose = require("mongoose");
const lightSchema = new mongoose.Schema(
  {
    roomId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Room",
      required: true,
    },
    status: {
      type: Boolean,
      default: false,
    },
    brightness: {
      type: Number,
      default: 100,
    },
    lastActivated: {
      type: Date,
      default: Date.now,
    },
    schedule: {
      start: {
        type: Date,
        required: false,
      },
      end: {
        type: Date,
        required: false,
      },
    },
    motionDetected: {
      type: Boolean,
      default: false,
    },
  },
  { versionKey: false }
);
const Light = mongoose.model("Light", lightSchema);
module.exports = Light;
 
1.2.6 Специфікація API для взаємодії серверної частини з клієнтами.
Для забезпечення коректної роботи та виконання всіх функцій програми були розроблені спеціалізовані API. Вони дозволяють обробляти запити від користувачів, забезпечуючи взаємодію між програмою, базами даних, сенсорами та іншими компонентами системи. Завдяки API програма отримує структурований доступ до даних і можливість працювати з інформацією. Крім того, API сприяють модульності системи, що полегшує її інтеграцію та подальшу підтримку.

 
 Рис. 4 – API пов’язані з реєстрацією, авторизацією та виходом з аккаунта

 
Рис. 5 – API для роботи з користувачами

 
Рис. 6 – API для роботи з логами системи

 
Рис. 7 – API для роботи з кімнатами

 
Рис. 8 – API для роботи з освітленням

Приклад коду логіки взаємодії серверної та клієнтської частини для створення нового користувача.

1 /**
2 * @swagger
3 * /auth/register:
4 *   post:
5 *     summary: Регістрація користувача
6 *     description: Створення нового користувача в системі.
7 *     tags: [Auth]
8 *     requestBody:
9 *       required: true
10 *       content:
11 *         application/json:
12 *           schema:
13 *             type: object
14*             properties:
15 *               email:
16 *                 type: string
17 *                 description: Адреса електронної пошти користувача.
18 *                 example: user@example.com
19 *               password:
20 *                 type: string
21 *                 description: Пароль користувача.
22 *                 example: password123
23 *               firstName:
24 *                 type: string
25 *                 description: Ім'я користувача.
26 *                 example: "Іван"
27 *               lastName:
28 *                 type: string
29 *                 description: Прізвище користувача.
30 *                 example: "Іванов"
31 *               profileImage:
32 *                 type: string
33 *                 description: URL зображення профілю користувача.
34 *                 example: "https://example.com/profile.jpg"
35 *     responses:
36 *       200:
37 *         description: Користувача успішно зареєстровано.
38 */
39 router.post("/register", async (req, res) => {
40 try {
41 const { email, password, firstName, lastName, profileImage } = req.body;
42
43 // Перевірка обов'язкових полів
44 if (!email || !password || !firstName || !lastName) {
45 return res.status(400).json({ message: "Всі поля є обов'язковими." });
46 }
47
48 // Перевірка наявності користувача
49 const existingUser = await User.findOne({ email });
50 if (existingUser) {
51 return res.status(400).json({
52 message: "Користувач з такою адресою електронної пошти вже існує.",
53 });
54 }
55
56 // Хешування пароля
57 const hashedPassword = await bcrypt.hash(password, 10);
58
59 // Створення нового користувача
60 const newUser = new User({
61 email,
62 password: hashedPassword,
63 firstName,
64 lastName,
65 profileImage,
66 });
67
68 // Збереження користувача в базі даних
69 await newUser.save();
70
71 // Створення JWT токену
72 const token = jwt.sign({ userId: newUser._id }, JWT_SECRET, {
73 expiresIn: "1h",
74 });
75
76 // Відправлення відповіді
77 res.status(200).json({
78 message: "Користувача успішно зареєстровано.",
79 token,
80 userId: newUser._id, // Повертаємо ID
81 });
82 } catch (error) {
83 console.error("Помилка реєстрації:", error);
84 res.status(500).json({ message: "Серверна помилка" });
85 }
86});

Висновок: під час лабораторної роботи було розроблено серверна частина програмної системи.

Посилання на відео: https://youtu.be/DZeGsCFwUU0

