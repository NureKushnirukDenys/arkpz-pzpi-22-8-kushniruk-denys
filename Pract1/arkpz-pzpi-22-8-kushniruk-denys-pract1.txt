Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Катедра ПІ



Звіт з практичного заняття №1
з дисципліни «Аналіз та рефакторинг коду»



Виконав: 
ст. гр. ПЗПІ-22-8
Кушнірук Д. О.

Перевірив: 
ст. викладач кат. ПІ 
Сокорчук І.П



Харків 2024



     1.1 Тема
     Основні рекомендації написання коду для мови програмування Rust
     1.2 Мета роботи
     Дослідити рекомендації щодо написання коду обраної мови програмування, підготувати презентацію з опрацьованого матеріалу.
	1.3 Хід роботи
     Основні рекомендації написання коду для Rust:

1. Рекомендвція: Використовувати регістр "snake_case" для іменування змінних та функцій.
Пояснення: Використання зрозумілих назв спрощує подальше читання та підтримку. Під час написання коду уникайте скорочень або абревіатур та використовуйте "snake_case" для назв змінних і функцій

1 // Поганий приклад - використано скорочення 
2 fn calc(x: i32) -> i32 {
3    x * 2
4 }

1 // Гарний приклад - зрозуміла назва
2 fn calculate_double(value: i32) -> i32 {
3    value * 2
4 }

2. Рекомендація: Дотримуватись структури коду. Структура коду важлива для підтримки читабельності й простоти налагодження. У Rust варто дотримуватись чіткого розподілу модулів та функцій
Пояснення: Організація коду в модулі дозволяє розділити функції для різних задач. Це підвищує зрозумілість і дозволяє легше тестувати окремі компоненти. Використовуйте модулі для організації коду. Розділяйте логіку на невеликі функції.

1 // Поганий приклад - без модульної структури
2 fn process_data(data: Vec<i32>) -> i32 {
3    let mut result = 0;
4    for i in data {
5        result += i * 2;
6    }
7    result
8 }

1 // Гарний приклад - організація через модулі
2 mod data_processing {
3    pub fn process(data: Vec<i32>) -> i32 {
4        let mut result = 0;
5        for i in data {
6            result += double(i);
7        }
8        result
9    }
10
11    fn double(value: i32) -> i32 {
12        value * 2
13    }
14 }

3. Рекомендація: Принципи рефакторингу. Рефакторинг полягає у покращенні структури коду без зміни його поведінки. Це важливо для підвищення читабельності, підтримуваності та продуктивності.
Пояснення: Великі функції ускладнюють розуміння та тестування коду. Розділення логіки на менші, спеціалізовані частини підвищує читабельність і підтримуваність.

1 // Поганий приклад - велика функція
2 fn process_data(data: Vec<i32>) -> i32 {
3    let mut result = 0;
4    for i in data {
5        result += i * 2;
6    }
7    result
8 }

1 // Гарний приклад - розділення на менші функції
2 fn process_data(data: Vec<i32>) -> i32 {
3    data.into_iter().map(double).sum()
4 }
5
6 fn double(value: i32) -> i32 {
7    value * 2
8 }

4. Рекомендація: Уникнення дублування. Повторення коду ускладнює його підтримку, оскільки змінюючи одну частину програми, ви ризикуєте пропустити інші дублікати
Пояснення: Повторення коду ускладнює його підтримку, оскільки змінюючи одну частину програми, ви ризикуєте пропустити інші дублікати. Використовуйте функції або шаблони, щоб усунути дублювання.

1 // Поганий приклад - дублювання логіки
2 fn calculate_area_rectangle(width: i32, height: i32) -> i32 {
3    width * height
4 }
5
6 fn calculate_area_square(side: i32) -> i32 {
7    side * side
8 }

1 // Гарний приклад - узагальнення логіки
2 fn calculate_area<T: Shape>(shape: T) -> i32 {
3    shape.area()
4 }
5
6 trait Shape {
7    fn area(&self) -> i32;
8 }
9
10 struct Rectangle {
11    width: i32,
12    height: i32,
13 }
14
15 impl Shape for Rectangle {
16    fn area(&self) -> i32 {
17        self.width * self.height
18    }
19 }
20
21 struct Square {
22    side: i32,
23 }
24
25 impl Shape for Square {
26    fn area(&self) -> i32 {
27        self.side * self.side
28    }
29 }

5. Рекомендація: Оптимізація продуктивності. Використовуйте посилання замість копій великих структур даних, коли це можливо.
Пояснення: У першому прикладі вся структура даних копіюється, що може уповільнити виконання. Використання посилань дозволяє уникнути зайвих операцій копіювання, що підвищує продуктивність.

1 // Поганий приклад - зайва копія вектора
2 fn sum_vector(data: Vec<i32>) -> i32 {
3    data.iter().sum()
4 }

1 // Гарний приклад - передача посилання на вектор
2 fn sum_vector(data: &Vec<i32>) -> i32 {
3    data.iter().sum()
4 }

6. Рекомендація: Обробка помилок. Використання Result для обробки помилок.
Пояснення: Тип Result використовується для функцій, які можуть завершитися помилкою. Він має два варіанти: Ok для успішного виконання і Err для помилки.

1 // Поганий приклад - використання panic! для обробки помилок
2 fn open_file(path: &str) -> String {
3    if path.is_empty() {
4        panic!("Path is empty");
5    }
6    // Умова відкрити файл...
7    String::from("file content")
8 }

1 // Гарний приклад - використання Result для обробки помилок
2 fn open_file(path: &str) -> Result<String, String> {
3    if path.is_empty() {
4        return Err(String::from("Path is empty"));
5    }
6    // Спроба відкрити файл...
7    Ok(String::from("file content"))
8 }

7. Рекомендація: Дотримання парадигм програмування в Rust (ООП)
Пояснення: Rust підтримує кілька парадигм програмування, зокрема об'єктно-орієнтоване (ООП) та функціональне програмування (ФП). Дотримання цих парадигм дозволяє розробникам ефективно використовувати переваги кожної підходу для створення чистого, модульного та продуктивного коду.
ООП в Rust реалізується через використання структур (struct), трейтов (trait) і реалізацій (impl). Хоча в Rust немає класів, можна досягти подібного результату завдяки трейтам та інкапсуляції.

1 // Поганий приклад - відсутність інкапсуляції, без методів
2 struct Car {
3    make: String,
4    model: String,
5    year: u32,
6 }
7
8 fn print_car_info(car: Car) {
9    println!("Car: {} {} {}", car.make, car.model, car.year);
10 }
11
12 let car = Car {
13   make: String::from("Toyota"),
14   model: String::from("Corolla"),
15    year: 2022,
16 };
17 print_car_info(car);

1 // Гарний приклад - інкапсуляція через методи структури
2 struct Car {
3    make: String,
4    model: String,
5    year: u32,
6 }
7 
8 impl Car {
9    fn new(make: &str, model: &str, year: u32) -> Self {
10        Car {
11            make: make.to_string(),
12            model: model.to_string(),
13            year,
14        }
15    }
16
17    fn print_info(&self) {
18        println!("Car: {} {} {}", self.make, self.model, self.year);
19    }
20 }
21
22 let car = Car::new("Toyota", "Corolla", 2022);
23 car.print_info();

8. Рекомендвція: Дотримання парадигм програмування в Rust (ФП)
Пояснення: Rust активно підтримує функціональне програмування, надаючи можливості роботи з чистими функціями, ітераторами, замиканнями та обробкою даних через функціональні трансформації.

1 // Поганий приклад - використання циклів замість функціональних ітераторів
2 fn sum_even_numbers(numbers: Vec<i32>) -> i32 {
3    let mut sum = 0;
4    for i in numbers {
5        if i % 2 == 0 {
6            sum += i;
7        }
8    }
9    sum
10 }

1 // Гарний приклад - використання ітераторів для функціональної обробки
2 fn sum_even_numbers(numbers: Vec<i32>) -> i32 {
3    numbers.into_iter()
4           .filter(|&x| x % 2 == 0)
5           .sum()
6 }

9. Рекомендація: Тестування коду. Rust надає вбудовані засоби для тестування, які сприяють підвищенню якості та підтримуваності коду. Дотримання рекомендацій щодо тестування допомагає уникнути помилок і полегшує роботу з кодом.
Пояснення: Тестування в Rust виконується за допомогою макросу #[test]. Тести можна написати безпосередньо у файлі коду, що полегшує відстеження змін і тестування функціональності.

1 // Поганий приклад - Відсутність тестів
2 fn add(x: i32, y: i32) -> i32 {
3    x + y
4 }
5
6 fn main() {
7    println!("Sum: {}", add(2, 3));
8 }

1 // Гарний приклад - написання тестів для функції
2 fn add(x: i32, y: i32) -> i32 {
3    x + y
4 }
5
6 #[cfg(test)]
7 mod tests {
8    use super::*;
9
10    #[test]
11    fn test_add() {
12        assert_eq!(add(2, 3), 5);
13        assert_eq!(add(-1, 1), 0);
14    }
15 }
16 
17 fn main() {
18    println!("Sum: {}", add(2, 3));
19 }

10. Рекомендація: Документування коду. Rust має вбудовану систему документування через коментарі у форматі Markdown
Пояснення: Документація пишеться перед функціями та структурами у вигляді коментарів з трьома косими рисками ///, що створює автоматичну документацію за допомогою команди cargo doc. Документування функцій з використанням прикладів коду (які також можуть бути протестовані під час виконання тестів) допомагає іншим розробникам зрозуміти призначення і використання функцій.

1 // Поганий приклад - відсутність документації
2 fn add(x: i32, y: i32) -> i32 {
3    x + y
4 }

1 // Гарний приклад - використання документаційних коментарів
2 /// Додає два числа і повертає результат.
3 ///
4 /// # Приклад
5 /// ```
6 /// let result = add(2, 3);
7 /// assert_eq!(result, 5);
8 /// ```
9 fn add(x: i32, y: i32) -> i32 {
10    x + y
11 }

Висновки: Під час виконання практичного завдання було досліджено особливості мови програмування Rust, та опановані основні рекомендації щодо написання якісного коду в Rust які значно покращують як код, так і процес його підтримки.
Посилання на відеозапис: https://youtu.be/E8y86EjWGdc

Список використаних джерел:
1. The Rust Programming Language https://doc.rust-lang.org/book/ Офіційна книга, що охоплює основи Rust, стиль коду та найкращі практики.
2. Rust by Example https://doc.rust-lang.org/stable/rust-by-example/ Практичний посібник з прикладами коду для різних концепцій Rust
3. Rust Documentation https://doc.rust-lang.org/std/  Офіційна документація стандартної бібліотеки Rust
4. Rust API Guidelines https://rust-lang.github.io/api-guidelines/ Рекомендації щодо проектування API в Rust, включаючи стилістичні та структурні аспекти
5. Effective Rust https://rust-lang.github.io/rust-everywhere/ Збірка порад і рекомендацій для написання якісного коду на Rust
6. Rust Testing Documentation https://doc.rust-lang.org/book/ch11-01-writing-tests.html Розділ документації, присвячений тестуванню в Rust
7. Rust Documentation for Error Handling https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html Опис механізмів обробки помилок в Rust

Додаток А


Рисунок А.1 – Титульний слайд презентації

Рисунок А.2 – Короткий огляд особливостей Rust

Рисунок А.3 – Стильові рекомендації написання коду

Рисунок А.4 – Дотримання структури під час написання коду

Рисунок А.5 – Принципи рефакторингу в Rust

Рисунок А.6 – Уникнення дублювання коду

Рисунок А.7 – Оптимізація продуктивності коду

Рисунок А.8 – Обробка помилок в Rust

Рисунок А.9 – Дотримання парадигм ООП

Рисунок А.10 – Дотримання парадигм ФП

Рисунок А.11 – Тестування коду в Rust

Рисунок А.12 – Документування коду під час нписання

Рисунок А.13 – Висновки щодо рекомендацій по оформленню коду

Рисунок А.14 – Використані джерела під час підготовки презентації